// Copyright 2016-2022, Pulumi Corporation.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package codegen

import (
	"bytes"
	"fmt"

	ijson "github.com/pulumi/crd2pulumi/internal/json"
	"github.com/pulumi/crd2pulumi/internal/versions"
	"github.com/pulumi/pulumi/pkg/v3/codegen/dotnet"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)

var unneededDotNetFiles = []string{
	"Meta/V1/Inputs/ObjectMetaArgs.cs",
	"Meta/V1/Outputs/ObjectMeta.cs",
	"Meta/V1/README.md",
	"Meta/README.md",
	"Provider.cs",
}

func GenerateDotNet(pg *PackageGenerator, name string) (map[string]*bytes.Buffer, error) {
	pkg := pg.SchemaPackageWithObjectMetaType()

	// Set up C# namespaces
	namespaces := map[string]string{}
	for _, groupVersion := range pg.GroupVersions {
		group, version, err := versions.SplitGroupVersion(groupVersion)
		if err != nil {
			return nil, fmt.Errorf("invalid version: %w", err)
		}
		groupPrefix, err := versions.GroupPrefix(group)
		if err != nil {
			return nil, fmt.Errorf("invalid version: %w", err)
		}
		namespaces[groupVersion] = cases.Title(language.Und).String(groupPrefix) + "." + versions.VersionToUpper(version)
	}
	namespaces["meta/v1"] = "Meta.V1"

	// Configure C# language-specific settings. Notice that we set
	// `compatibility` to `kubernetes20`. This is because the actual ObjectMeta
	// class defined in the .NET SDK is located at
	// `Pulumi.Kubernetes.Types.Outputs.Meta.V1.ObjectMeta`. This path would
	// only get generated properly if `compatibility` was `kubernetes20`.
	oldName := pkg.Name
	pkg.Name = name
	var err error
	pkg.Language["csharp"], err = ijson.RawMessage(map[string]any{
		"packageReferences": map[string]string{
			"Pulumi.Kubernetes": "3.*",
		},
		"compatibility":          "kubernetes20",
		"dictionaryConstructors": true,
		"namespaces":             namespaces,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to marshal JSON message: %w", err)
	}

	files, err := dotnet.GeneratePackage(PulumiToolName, pkg, nil, nil)
	if err != nil {
		return nil, fmt.Errorf("could not generate .NET package: %w", err)
	}

	pkg.Name = oldName
	delete(pkg.Language, "csharp")

	namespaceName := dotnet.Title(name)
	files["KubernetesResource.cs"] = []byte(kubernetesResource(namespaceName))
	files["Utilities.cs"] = []byte(dotNetUtilities(namespaceName))

	// Delete unneeded files
	for _, unneededFile := range unneededDotNetFiles {
		delete(files, unneededFile)
	}

	buffers := map[string]*bytes.Buffer{}
	for name, code := range files {
		buffers[name] = bytes.NewBuffer(code)
	}

	return buffers, nil
}

func kubernetesResource(name string) string {
	return `// Copyright 2016-2022, Pulumi Corporation
namespace Pulumi.` + name + `{
    /// <summary>
    /// A base class for all Kubernetes resources.
    /// </summary>
    public abstract class KubernetesResource : CustomResource
    {
        /// <summary>
        /// Standard constructor passing arguments to <see cref="CustomResource"/>.
        /// </summary>
        internal KubernetesResource(string type, string name, ResourceArgs? args, CustomResourceOptions? options = null)
            : base(type, name, args, options)
        {
        }

        /// <summary>
        /// Additional constructor for dynamic arguments received from YAML-based sources.
        /// </summary>
        internal KubernetesResource(string type, string name, DictionaryResourceArgs? args, CustomResourceOptions? options = null)
            : base(type, name, args, options)
        {
        }
    }
}
`
}

// For some reason, we get a `Missing embedded version.txt file` error if we
// tried running `pulumi up` with the normal `Utilities.cs` file.
// As a temporary fix, this modified `Utilities.cs` file just removes the
// `static Utilities()` method.
func dotNetUtilities(name string) string {
	return `// *** WARNING: this file was generated by crd2pulumi. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Reflection;
using Pulumi.Kubernetes;

namespace Pulumi.` + name + `
{
    static class Utilities
    {
        public static string Version { get; } = GetVersion();

        private static string GetVersion()
        {
            const string UtilitiesType = "Pulumi.Kubernetes.Utilities";
            const string VersionProperty = "Version";

            Type? type = Assembly.GetAssembly(typeof(Provider))?.GetType(UtilitiesType);
            if (type is null)
            {
                throw new InvalidOperationException($"{UtilitiesType} type could not be obtained.");
            }

            PropertyInfo? prop = type.GetProperty(VersionProperty, BindingFlags.Static | BindingFlags.Public);
            if (prop is null)
            {
                throw new InvalidOperationException($"{UtilitiesType}.{VersionProperty} property could not be obtained.");
            }

            var result = prop.GetValue(type, null) as string;
            if (result is null)
            {
                throw new InvalidOperationException($"Expected {UtilitiesType}.{VersionProperty} to return a non-null string.");
            }
            return result;
        }
    }

	internal sealed class ` + name + `ResourceTypeAttribute : Pulumi.ResourceTypeAttribute
	{
		public ` + name + `ResourceTypeAttribute(string type) : base(type, Utilities.Version)
		{
		}
	}
}
`
}
